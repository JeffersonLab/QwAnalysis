#include "QwGUIInjector.h"

ClassImp(QwGUIInjector);


const char *QwGUIInjector::InjectorTrees[INJECTOR_DET_TRE_NUM] = 
  {
    "HEL_Tree",
    "MPS_Tree"
  };
const char *QwGUIInjector::InjectorHists[INJECTOR_DET_HST_NUM] = 
  { "yield_qwk_bcm0l02.hw_sum",
    "asym_qwk_bcm0l02.hw_sum",
    "yield_phasemonitor.hw_sum",
    "phasemonitor.hw_sum",
    "asym_phasemonitor.hw_sum", 
    "qwk_bcm0l02.hw_sum"};

    //    "diff_qwk_1i02RelX.hw_sum",
    //    "diff_qwk_1i02RelY.hw_sum"};

QwGUIInjector::QwGUIInjector(const TGWindow *p, const TGWindow *main, const TGTab *tab,
			       const char *objName, const char *mainname, UInt_t w, UInt_t h)
  : QwGUISubSystem(p,main,tab,objName,mainname,w,h)
{ 
  dTabFrame = NULL;
  dCanvas = NULL;  
  dTabLayout = NULL;
  dCnvLayout = NULL;
  dBtnLayout = NULL;

  dButtonPos = NULL;
  dButtonCharge = NULL;

  AddThisTab(this);
  //MakeLayout();
}

QwGUIInjector::~QwGUIInjector()
{
  if(dTabFrame)  delete dTabFrame;
  if(dCanvas)    delete dCanvas;  
  if(dTabLayout) delete dTabLayout;
  if(dCnvLayout) delete dCnvLayout;
  if(dBtnLayout) delete dBtnLayout;

  RemoveThisTab(this);
  IsClosing(GetName());
}

void QwGUIInjector::MakeLayout()
{
  dTabLayout = new TGLayoutHints(kLHintsLeft | kLHintsTop | 
				 kLHintsExpandX | kLHintsExpandY);
  dCnvLayout = new TGLayoutHints(kLHintsTop | kLHintsExpandX | kLHintsExpandY,
				 10, 10, 11, 12);
  //kLHintsBottom | kLHintsExpandX,
  dBtnLayout = new TGLayoutHints(kLHintsExpandX | kLHintsTop,
				    5,5,5,5);

  dTabFrame = new TGHorizontalFrame(this,10,10);
  dCanvas   = new TRootEmbeddedCanvas("pC", dTabFrame,10, 10);  
  
  dButtonPos = new TGTextButton(this, "&Beam Position",  1);
  //dButtonPos->SetCommand("printf(\"Reading position information %s\\n\","
  //                       "gROOT->GetVersion());");

  dButtonCharge = new TGTextButton(this, "&Beam Charge", 2);
  // dButtonCharge->SetCommand("printf(\"Reading charge asymmetires \n\")" );
 
  dTabFrame->AddFrame(dCanvas,dCnvLayout);
  dTabFrame->Resize(GetWidth(),GetHeight());

  AddFrame(dTabFrame,dTabLayout);
  AddFrame(dButtonPos, dBtnLayout);
  AddFrame(dButtonCharge, dBtnLayout);

  dButtonPos -> Associate(this);
  dButtonCharge -> Associate(this);


  dCanvas->GetCanvas()->SetBorderMode(0);
  dCanvas->GetCanvas()->Connect("ProcessedEvent(Int_t,Int_t,Int_t,TObject*)",
				"QwGUIInjector",
				this,"TabEvent(Int_t,Int_t,Int_t,TObject*)");

 //  TCanvas *mc = dCanvas->GetCanvas();
//   mc->Divide( INJECTOR_DET_HST_NUM/2, INJECTOR_DET_HST_NUM/2);

   Int_t wid = dCanvas->GetCanvasWindowId();
   TSuperCanvas *super_canvas = new TSuperCanvas("", 10, 10, wid);
   dCanvas->AdoptCanvas(super_canvas);

   super_canvas -> Divide( INJECTOR_DET_HST_NUM/2, INJECTOR_DET_HST_NUM/2);

}

void QwGUIInjector::OnReceiveMessage(char *obj)
{
//   TString name = obj;
//   char *ptr = NULL;

}

void QwGUIInjector::OnObjClose(char *obj)
{
  if(!strcmp(obj,"dROOTFile")){
    printf("Called QwGUIInjector::OnObjClose\n");

    dROOTCont = NULL;
  }
}


void QwGUIInjector::OnNewDataContainer()
{

  TObject *obj;
  TObject *copy;
 
  ClearData();

  if(dROOTCont){
    for(int p = 0; p < INJECTOR_DET_TRE_NUM; p++) {
      obj = dROOTCont->ReadTree(InjectorTrees[p]);
      if(obj)
	{
	  copy = obj->Clone();
	  HistArray.Add(copy);
	}
    }
    PlotData();
  }
};

void QwGUIInjector::OnRemoveThisTab()
{

};

void QwGUIInjector::ClearData()
{

  TObject *obj;
  TIter next(HistArray.MakeIterator());
  obj = next();
  while(obj){    
    delete obj;
    obj = next();
  }
  HistArray.Clear();
}

void QwGUIInjector::PlotData()
{
  bool debug = false;

  TObject *obj;
  TCanvas *mc = dCanvas->GetCanvas();

  for(int t=0; t<INJECTOR_DET_TRE_NUM; t++) 
    {
      obj = HistArray.At(t);
      if(debug) printf("%s\n", obj->GetName());
      for(Short_t p = 0; p < INJECTOR_DET_HST_NUM; p++) 
	{
	  if( ((TTree*) obj)->FindLeaf(InjectorHists[p]) )
	    {
	      if(debug) printf("%s\n",InjectorHists[p]);
	      mc -> cd(p+1);
	      obj -> Draw(InjectorHists[p]);
	    }
	}
    }
  
  mc->Modified();
  mc->Update();
};

void QwGUIInjector::TabEvent(Int_t event, Int_t x, Int_t y, TObject* selobject)
{
  if(event == kButton1Double){
    Int_t pad = dCanvas->GetCanvas()->GetSelectedPad()->GetNumber();
    
    if(pad > 0 && pad <= INJECTOR_DET_HST_NUM)
      {
	RSDataWindow *dMiscWindow = new RSDataWindow(GetParent(), this,
						     GetNewWindowName(),"QwGUIInjector",
						     HistArray[pad-1]->GetTitle(), PT_HISTO_1D,600,400);
	if(!dMiscWindow){
	  return;
	}
	DataWindowArray.Add(dMiscWindow);
	dMiscWindow->SetPlotTitle((char*)HistArray[pad-1]->GetTitle());
	dMiscWindow->DrawData(*((TH1D*)HistArray[pad-1]));
	SetLogMessage(Form("Looking at %s\n",(char*)HistArray[pad-1]->GetTitle()),kTrue);

	return;
      }
  }
}


Bool_t QwGUIInjector::ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2)
{
  // Process events generated by the object in the frame.
  
  switch (GET_MSG(msg))
    {
    case kC_TEXTENTRY:
      switch (GET_SUBMSG(msg)) 
	{
	case kTE_ENTER:
	  switch (parm1) 
	    {
	    default:
	      break;
	    }
	default:
	  break;
	}
      
    case kC_COMMAND:
      switch (GET_SUBMSG(msg))
	{
	case kCM_BUTTON:
	  {
	    TCanvas *mc = dCanvas->GetCanvas();
	    TIter next(HistArray.MakeIterator());
	    
	    switch(parm1)
	      {
	      case 1:
		printf("text button id %ld pressed\n", parm1);	
		mc->Clear();  
		mc->Divide( 2,2);
// 		for(Int_t i=0;i<2;i++){
// 		  InjectorHists[INJECTOR_DET_HST_NUM];
// 		  std::cout<<InjectorHists[i]<<std::endl;
// 		  InjectorHists[i]->Draw();
// 		}
// 		TObject *obj;
	
// 		obj = next();
// 		while(obj){
// 		  std::cout<<"here!!\n";
// 		  mc->cd(ind);
// 		  ((TH1*)obj)->Draw("");
// 		  ind++;
// 		  obj = next();
// 		}

// 		mc->Modified();
// 		mc->Update();

  		PlotData();
		mc->Update();
		break;

	      case 2:
		
// 		printf("text button id %ld pressed\n", parm1);
 
		PlotData();
// 		TF1* f = new TF1("f","sin(x)",0,10);
// 		mc->Divide( 2,2);
// 		mc->cd(1);
// 		f->Draw();

		break;
	      }

	    break;
	  }
	case kCM_COMBOBOX:
	  {
	    switch (parm1) {
	    case M_TBIN_SELECT:
	      break;
	    }
	  }
	  break;

	case kCM_MENUSELECT:
	  break;
      
	case kCM_MENU:

	  switch (parm1) {
	
	  case M_FILE_OPEN:
	    break;

	
	    
	  default:
	    break;
	  }
	  
	default:
	  break;
	}
      
    default:
    break;
    }
  
  return kTRUE;
}
