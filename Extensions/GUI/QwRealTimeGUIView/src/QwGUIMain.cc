/*------------------------------------------------------------------------*//*!

 \defgroup QwGUIMain QwGUIMain

 \section myoverview Overview of the Qweak analysis GUI frontend
    This group of classes is meant to implement a basic GUI frontend with
    a tab environment for each major subsystem, which, for the moment, will
    read the ROOT file generated by the main analysis program.

    The GUI is based on ROOT classes and a set of utility classes contained
    in a library called QwGUIRootLib-vers.a, where "vers" is the current
    subversion assigned version of the overall QwAnalyzer software.

    Things are meant to be prepared in such a way, as to make it easy for
    other people to implement their own sub system specific data display.
    One can follow the implementation of the main detector subsystem as an
    example.

*//*-------------------------------------------------------------------------*/


/*------------------------------------------------------------------------*//*!

 \file QwGUIMain.cc
 \author Michael Gericke

 \brief main(...) function and MainFrame class for the QwGUI executable




*//*-------------------------------------------------------------------------*/

#include "QwGUIMain.h"

QwGUIMain::QwGUIMain(const TGWindow *p, ClineArgs clargs, UInt_t w, UInt_t h)
  : TGMainFrame(p, w, h), dMWWidth(w), dMWHeight(h), dClArgs(clargs)
{

   ///  First, fill the search paths for the parameter files; this sets a
  ///  static variable within the QwParameterFile class which will be used by
  ///  all instances.
  ///  The "scratch" directory should be first.
  QwParameterFile::AppendToSearchPath(getenv_safe_string("QW_PRMINPUT"));
  QwParameterFile::AppendToSearchPath(getenv_safe_string("QWANALYSIS") + "/Parity/prminput");
  QwParameterFile::AppendToSearchPath(getenv_safe_string("QWANALYSIS") + "/Analysis/prminput");

  std::set_new_handler(0);

  MainDetSubSystem      = NULL;
  LumiDetSubSystem      = NULL;
  InjectorSubSystem     = NULL;
  CorrelationSubSystem  = NULL;
  HallCBeamlineSubSystem = NULL;

  dCurRun               = 0;
  MCnt                  = 0;

  dProcessing           = false;
  dProcessHalt          = false;

 
  
  dMapFileOpen          = false;
  dRunOpen              = false;

  dROOTFile             = NULL;

  dTBinEntry            = NULL;
  dTBinEntryLayout      = NULL;
  dRunEntry             = NULL;
  dRunEntryLayout       = NULL;
  dHorizontal3DLine     = NULL;
  dUtilityFrame         = NULL;
  dUtilityLayout        = NULL;

  dTab                  = NULL;
  dTabLayout            = NULL;

  dMainCanvas           = NULL;
  dMainCnvFrame         = NULL;
  dMainTabFrame         = NULL;
  dMainTabLayout        = NULL;
  dMainCnvLayout        = NULL;

  //  dLogText              = NULL;
  dLogEdit              = NULL;
  dLogTabFrame          = NULL;
  dLogTabLayout         = NULL;
  dLogEditLayout        = NULL;


  dMenuBar              = NULL;
  //  dMenuFile             = NULL;
  dMenuTabs             = NULL;
  dMenuLoadMap          = NULL;
  dMenuHistoState       = NULL;
  //  dMenuHelp             = NULL;
  dMenuBarLayout        = NULL;
  dMenuBarItemLayout    = NULL;
  //  dMenuBarHelpLayout    = NULL;

  memset(dLogfilename,'\0',sizeof(dLogfilename));
  memset(dRootfilename,'\0',sizeof(dRootfilename));
  memset(dMiscbuffer, '\0', sizeof(dMiscbuffer));
  memset(dMiscbuffer2, '\0', sizeof(dMiscbuffer2));


  MakeMenuLayout();
  MakeUtilityLayout();
  MakeMainTab();
  //  MakeLogTab();

  SetWindowName("Qweak RealTime Data Analysis GUI");


  MapSubwindows();
  Resize(GetDefaultSize());
  MapWindow();

  if (dClArgs.detectormap==kTRUE){
    printf("custom detector map included - %s \n",dClArgs.file);
    strcpy(dDetMapFile,dClArgs.file);
  }
  else{
     strcpy(dDetMapFile,"detectors.map");
  }

  LoadChannelMapFiles(dDetMapFile);//loads the channel map files for all the subsystems

  if(!GetSubSystemPtr("Main Detectors") && dMDChannelMap.Length()){
    MainDetSubSystem = new QwGUIMainDetector(fClient->GetRoot(), this, dTab,"Main Detectors",
					     "QwGUIMain", dMWWidth-15,dMWHeight-180);
    MainDetSubSystem->LoadHistoMapFile(dMDChannelMap);
  }
  if(!GetSubSystemPtr("Lumi Detectors") && dLumiChannelMap.Length()){
    LumiDetSubSystem = new QwGUILumiDetector(fClient->GetRoot(), this, dTab,"Lumi Detectors",
					     "QwGUIMain", dMWWidth-15,dMWHeight-180);
    LumiDetSubSystem->LoadHistoMapFile(dLumiChannelMap);
  }
  if(!GetSubSystemPtr("Injector")&& dInjectorChannelMap.Length()){
    InjectorSubSystem = new QwGUIInjector(fClient->GetRoot(), this, dTab,"Injector",
					  "QwGUIMain", dMWWidth-15,dMWHeight-180);
    InjectorSubSystem->LoadHistoMapFile(dInjectorChannelMap);
  }

  if(!GetSubSystemPtr("HallC Beamline") && dHallCChannelMap.Length()){
    HallCBeamlineSubSystem = new QwGUIHallCBeamline(fClient->GetRoot(), this, dTab,"HallC Beamline",
					  "QwGUIMain", dMWWidth-15,dMWHeight-180);
    HallCBeamlineSubSystem->LoadHistoMapFile(dHallCChannelMap);
  }


  if(!GetSubSystemPtr("Correlation Plots"))
    CorrelationSubSystem = new QwGUICorrelationPlots(fClient->GetRoot(), this, dTab,"Correlation Plots",
					  "QwGUIMain", dMWWidth-15,dMWHeight-180);
  
}

QwGUIMain::~QwGUIMain()
{
  delete MainDetSubSystem      ;
  delete LumiDetSubSystem      ;
  delete InjectorSubSystem     ;
  // delete EventDisplaySubSystem ;
  delete CorrelationSubSystem  ;
  delete HallCBeamlineSubSystem;

  //  delete dROOTFile             ;

  delete dTBinEntry            ;
  delete dTBinEntryLayout      ;
  delete dRunEntry             ;
  delete dRunEntryLayout       ;
  //  delete dHorizontal3DLine     ;
  delete dUtilityFrame         ;
  delete dUtilityLayout        ;

  delete dTab                  ;
  delete dTabLayout            ;

  delete dMainCanvas           ;
  delete dMainCnvFrame         ;
  delete dMainTabFrame         ;
  delete dMainTabLayout        ;
  delete dMainCnvLayout        ;

  // delete dLogText              ;
  delete dLogEdit              ;
  delete dLogTabFrame          ;
  delete dLogTabLayout         ;
  delete dLogEditLayout        ;


  delete dMenuBar              ;
  //  delete dMenuFile             ;
  delete dMenuTabs             ;
  //  delete dMenuHelp             ;
  delete dMenuBarLayout        ;
  delete dMenuBarItemLayout    ;
  //  delete dMenuBarHelpLayout    ;
  delete dMenuLoadMap          ;

}

void QwGUIMain::LoadChannelMapFiles(TString detfile)
{
  TString varname, varvalue;
  TString subsysname,subsysmapname;
  QwParameterFile mapstr(detfile.Data());  //Open the file
  TString subsystemname;
  QwParameterFile *section;
  dMDChannelMap="";
  dHallCChannelMap="";
  dInjectorChannelMap="";
  dLumiChannelMap="";

  std::cout << "Adding ............ " << std::endl;
  Int_t output_width = 40;

  while ( (section=mapstr.ReadNextSection(subsystemname)) )
    {
      while (section->ReadNextLine())
	{
	  section->TrimComment('#');   // Remove everything after a '#' character.
	  section->TrimWhitespace();   // Get rid of leading and trailing spaces.
	  if (section->LineIsEmpty())  continue;
	  if (section->HasVariablePair("=",varname,varvalue)){
	    varname.ToLower();
	    if (varname=="name")
	      subsysname=varvalue;
	    else if (varname=="map")
	      subsysmapname=varvalue;
	  }
	}
      if (subsystemname=="QwBeamLine"){//we have hallc and injector beamlines
	subsysname.ToLower();
	if (subsysname.Contains("hallc") || subsysname.Contains("hall c")) {
	  dHallCChannelMap=subsysmapname;
	  std::cout << std::setw(output_width) << dHallCChannelMap << "\n";
	}
	else if (subsysname.Contains("injector")) {
	  dInjectorChannelMap=subsysmapname;
	  std::cout << std::setw(output_width) << dInjectorChannelMap << "\n";
	}
      }
      else if (subsystemname=="QwMainCerenkovDetector"){
	dMDChannelMap=subsysmapname;
	std::cout << std::setw(output_width) << dMDChannelMap << "\n";
      }
      else if (subsystemname=="QwLumi"){
	dLumiChannelMap=subsysmapname;
	std::cout << std::setw(output_width) << dLumiChannelMap  << "\n";
      }//add any other subsystem included in RT
      
      // std::cout << std::setw(30) << subsystemname
      // 		<< " "
      // 		<< std::setw(30) << subsysmapname
      // 		<< std::endl;
    }
  std::cout  << std::setw(Int_t(1.8*output_width)) << ".............. to QwRealTimeGUI " << std::endl;

};

void QwGUIMain::MakeMenuLayout()
{
  dMenuBarLayout = new TGLayoutHints(kLHintsTop | kLHintsLeft | kLHintsExpandX,
				     0, 0, 1, 1);
  dMenuBarItemLayout = new TGLayoutHints(kLHintsTop | kLHintsLeft, 0, 4, 0, 0);
  
  dMenuLoadMap = new TGPopupMenu(fClient->GetRoot());
  dMenuLoadMap->AddEntry("Load Memory", M_VIEW_MAPLOAD); 
  dMenuLoadMap->AddSeparator();
  dMenuLoadMap->AddEntry("Exit",  M_FILE_EXIT);

  dMenuHistoState = new TGPopupMenu(fClient->GetRoot());
  dMenuHistoState->AddEntry("Reset Histos", M_HISTO_RESET); 
  dMenuHistoState->AddSeparator();
  dMenuHistoState->AddEntry("Accumulate Histos",   M_HISTO_ACCUMULATE);
  dMenuHistoState->AddSeparator();
  dMenuHistoState->AddEntry("Pause Histos",   M_HISTO_PAUSE);

  

  dMenuTabs = new TGPopupMenu(fClient->GetRoot());
  dMenuTabs->AddEntry("View Log", M_VIEW_LOG);

  dMenuTabs->Associate(this);
  dMenuLoadMap->Associate(this);
  dMenuHistoState->Associate(this);
 

  dMenuBar = new TGMenuBar(this, 1, 1, kHorizontalFrame);
  //dMenuBar->AddPopup("&File", dMenuFile, dMenuBarItemLayout);
  dMenuBar->AddPopup("&MemoryMap", dMenuLoadMap, dMenuBarItemLayout);
  dMenuBar->AddPopup("H&istograms", dMenuHistoState, dMenuBarItemLayout);
  dMenuBar->AddPopup("&Tabs", dMenuTabs, dMenuBarItemLayout);
  // dMenuBar->AddPopup("&Help", dMenuHelp, dMenuBarHelpLayout);
 

  AddFrame(dMenuBar, dMenuBarLayout);
  dMenuTabs->CheckEntry(M_VIEW_LOG);
}

void QwGUIMain::MakeUtilityLayout()
{

}

void QwGUIMain::MakeMainTab()
{

  dTabLayout = new TGLayoutHints(kLHintsBottom | kLHintsExpandX | kLHintsExpandY,
				 2, 2, 5, 1);
  dTab = new TGTab(this,dMWWidth-15,dMWHeight-80);

  if(TabActive("Main")) return;

  dMainTabLayout = new TGLayoutHints(kLHintsLeft | kLHintsTop |
				     kLHintsExpandX | kLHintsExpandY);
  dMainCnvLayout = new TGLayoutHints(kLHintsTop | kLHintsExpandX | kLHintsExpandY,
				     0, 0, 1, 2);

  TGCompositeFrame *tf = dTab->AddTab("Main");

  dMainTabFrame = new TGHorizontalFrame(tf,10,10);
  dMainCanvas   = new TRootEmbeddedCanvas("pC", dMainTabFrame,10, 10);
  dMainTabFrame->AddFrame(dMainCanvas,dMainCnvLayout);
  dMainTabFrame->Resize(dMWWidth-15,dMWHeight-110);
  tf->AddFrame(dMainTabFrame,dMainTabLayout);
  AddFrame(dTab, dTabLayout);

  dMainCanvas->GetCanvas()->SetBorderMode(0);
  // dMainCanvas->GetCanvas()->Connect("Picked(TPad*, TObject*, Int_t)","QwGUIMain",
  // 				    this,"PadIsPicked(TPad*, TObject*, Int_t)");
  dMainCanvas->GetCanvas()->Connect("ProcessedEvent(Int_t,Int_t,Int_t,TObject*)",
				    "QwGUIMain",
				    this,"MainTabEvent(Int_t,Int_t,Int_t,TObject*)");
}

void QwGUIMain::MakeLogTab()
{

}

void QwGUIMain::RemoveTab(QwGUISubSystem* sbSystem)
{
  if(!sbSystem) return;
  const char *TabName = sbSystem->GetName();
  if(!TabActive(TabName)) return;
  int tab = GetTabIndex(TabName);
  if(tab < 0) return;

  dMenuTabs->UnCheckEntry(GetTabMenuID(TabName));
  sbSystem->TabMenuEntryChecked(kFalse);
  UnMapLayout(tab);
}

void QwGUIMain::AddATab(QwGUISubSystem* sbSystem)
{
  if(!dMenuTabs) return;
  if(!sbSystem) return;

  int flag = 0;
  TString s = sbSystem->GetName();
  TObject *obj;
  TIter next(dMenuTabs->GetListOfEntries());

  //Sequence naming of menu items not currently implemented/useful
  //
  //int seq = 1;
  //char sequence[100];
  //   while(!flag){
  //     flag = 1;
  //     while(obj = next()){
  //       TGMenuEntry *entry = (TGMenuEntry*)obj;
  //       if(s == entry->GetLabel()->GetString()){
  // 	if(seq >= 2) s.Resize(s.Length()-3);
  // 	sprintf(sequence," % 2d",seq); seq++;
  // 	s += sequence;
  // 	flag = 0;
  // 	break;
  //       }
  //     }
  //     next.Reset();
  //   }
  //   MCnt++;
  //   dMenuTabs->AddEntry(s, M_TABS+MCnt);

  obj = next();
  while(obj){
    TGMenuEntry *entry = (TGMenuEntry*)obj;
    //       printf("%s %d\n",entry->GetLabel()->GetString(),entry->GetEntryId());
    if(s == entry->GetLabel()->GetString()){
      flag = 1;
      break;
    }
    obj = next();
  }

  if(!flag){
    Long_t mID = GetNewTabMenuID();
    dMenuTabs->AddEntry(s,mID);
    sbSystem->SetTabMenuID(mID);
    SubSystemArray.Add(sbSystem);
    sbSystem->SubSystemLayout();
  }

  if(TabActive(s.Data())) return;

  dTab->AddTab(s.Data(),sbSystem);
  dMenuTabs->CheckEntry(GetTabMenuID(s.Data()));
  sbSystem->TabMenuEntryChecked(kTrue);
  MapLayout();
}

Int_t QwGUIMain::GetTabMenuID(const char* TabName)
{
  if(!dMenuTabs) return 0;

  TString s = TabName;
  TObject *obj;
  TIter next(dMenuTabs->GetListOfEntries());

  obj = next();
  while(obj){
    TGMenuEntry *entry = (TGMenuEntry*)obj;
    //       printf("%s %d\n",entry->GetLabel()->GetString(),entry->GetEntryId());
    if(s == entry->GetLabel()->GetString()) return entry->GetEntryId();
    obj = next();
  }

  return 0;
}

const char* QwGUIMain::GetTabMenuLabel(Long_t mID)
{
  if(!dMenuTabs) return 0;

  TString s;
  TObject *obj;
  TIter next(dMenuTabs->GetListOfEntries());

  obj = next();
  while(obj){
    TGMenuEntry *entry = (TGMenuEntry*)obj;
    //       printf("%s %d\n",entry->GetLabel()->GetString(),entry->GetEntryId());
    if(mID == entry->GetEntryId()) {
      s = entry->GetLabel()->GetString();
      return s.Data();
    }
    obj = next();
  }

  return 0;
}


Bool_t QwGUIMain::TabActive(const char *str)
{
  int nt = dTab->GetNumberOfTabs();
  for (int i = 0 ; i < nt; i++) {
    TString s = dTab->GetTabTab(i)->GetString();
    if (s == str) {return kTrue;}
  }
  return kFalse;
}

Int_t QwGUIMain::GetTabIndex(const char *str)
{
  TString s;
  TString label = str;
  int nt = dTab->GetNumberOfTabs();
  for (int i = 0 ; i < nt; i++) {
    s = dTab->GetTabTab(i)->GetString();
    if (s == label) {return i;}
  }
  return -1;
}

void QwGUIMain::MainTabEvent(Int_t event, Int_t x, Int_t y, TObject* selobject)
{
//   if(event == kButton1Double){
//     Int_t pad = dMainCanvas->GetCanvas()->GetSelectedPad()->GetNumber();
//   }
}


// Wait, but continue to process events.
void QwGUIMain::SleepWithEvents(int seconds)
{
  time_t start, now;
  time(&start);
  do {
    time(&now);
    gSystem->ProcessEvents();
  } while (difftime(now,start) < seconds) ;
}

QwGUISubSystem *QwGUIMain::GetSubSystemPtr(const char *name)
{

  TObject *obj;
  TIter next(SubSystemArray.MakeIterator());
  obj = next();
  while(obj){
    QwGUISubSystem *entry = (QwGUISubSystem*)obj;
    if(!strcmp(name,entry->GetName())){
      return entry;
    }
    obj = next();
  }

  return 0;

}

// void QwGUIMain::PlotMainData(ERPlotTypes ptype)
// {
// }

void QwGUIMain::OnLogMessage(const char *msg)
{
  // Append(msg,kFalse);
}

void QwGUIMain::OnObjClose(const char *objname)
{
  if(!objname) return;

//   TString name = objname;

//   if(name.Contains("dROOTFile")){
//     dROOTFile = NULL;
// #ifdef QWGUI_DEBUG
//     printf("Received dROOTFile IsClosing signal\n");
// #endif
//  }

//   TObject *obj;
//   TIter next(SubSystemArray.MakeIterator());
//   obj = next();
//   while(obj){
//     QwGUISubSystem *entry = (QwGUISubSystem*)obj;
//     if(!strcmp(objname,entry->GetName())){
//       SubSystemArray.Remove(entry);
//     }
//     obj = next();
//   }
}

void QwGUIMain::OnReceiveMessage(const char *obj)
{
}



Int_t QwGUIMain::OpenMapFile()
{

  sprintf(dMiscbuffer2,"%s/QwMemMapFile.map",gSystem->Getenv("QW_ROOTFILES"));
  
  try {
    if(IsMapFileOpen()) CloseMapFile();
  }
  catch( char * str ) {
    printf("QwGUIMain::OpenMapFile - Memory map error\n");
  }
  char filename[NAME_STR_MAX];
  
  dROOTFile = new RDataContainer(fClient->GetRoot(), this,"dROOTFile","QwGUIMain","ROOT",FM_UPDATE,FT_ROOT);
  try { 
    dROOTFile->OpenMapFile(dMiscbuffer2);//open the map file
     
  }
  catch( char * str ) {
    printf("QwGUIMain::OpenMapFile - Memory map error\n");
  }

  TObject *obj;
  TIter next(SubSystemArray.MakeIterator());
  obj = next();
 
  while(obj){
    QwGUISubSystem *entry = (QwGUISubSystem*)obj;
    entry->SetDataContainer(dROOTFile);
    obj = next();
  }

  
  SetMapFileOpen(kTrue);
  strcpy(filename,dMiscbuffer2);
  SetMapFileName(filename);
  
  return kTRUE;
}



void QwGUIMain::CloseMapFile()
{

  if(dROOTFile != NULL){
    dROOTFile->Close(kFalse);
    dROOTFile = NULL;
  }
  SetMapFileOpen(kFalse);
}

void QwGUIMain::CloseWindow()
{
 
  gApplication->Terminate(0);

}

Bool_t QwGUIMain::ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2)
{
  // Handle messages send to the MainFrame object. E.g. all menu button
  // messages.

  Long_t mTabID = 0;
  //printf("\n ProcessMessage 1\n");
  switch (GET_MSG(msg)){

  case kC_TEXTENTRY:
    switch (GET_SUBMSG(msg)) {
    case kTE_ENTER:
      switch (parm1) {

      case M_RUN_SELECT:
	break;

      default:
	break;
      }

    default:
      break;
    }

  case kC_COMMAND:
    switch (GET_SUBMSG(msg)) {

    case kCM_COMBOBOX:
      {
	switch (parm1) {
	case M_TBIN_SELECT:
	  break;
	}
      }
      break;

    case kCM_MENUSELECT:
      break;

    case kCM_MENU:

      for(int n = M_TABS; n <= M_TABS+MCnt; n++ ){
	mTabID = n;
	if(parm1 == mTabID){

	  if(dMenuTabs->IsEntryChecked(mTabID)){
	    RemoveTab((QwGUISubSystem*)dTab->GetTabContainer(GetTabIndex(GetTabMenuLabel(mTabID))));
	  }
	  else{

	    TObject *obj;
	    TIter next(SubSystemArray.MakeIterator());
	    obj = next();
	    while(obj){
	      QwGUISubSystem *entry = (QwGUISubSystem*)obj;
	      if(!strcmp(GetTabMenuLabel(mTabID),entry->GetName()))
		AddATab(entry);
	      obj = next();
	    }
	  }

	  break;
	}
      }
      //printf("\n ProcessMessage 1\n");
      switch (parm1) {

      case M_VIEW_LOG:
	// if(dMenuTabs->IsEntryChecked(M_VIEW_LOG)){
	//   RemoveLogTab();
	// }
	// else{
	//   MakeLogTab();
	// }
	break;

      case M_VIEW_MAPLOAD:
	printf("\n Loading Memory \n");
	try{
	  OpenMapFile();
	}
	catch( char * str ) {
	  printf("QwGUIMain::OpenMapFile - Memory map error\n");
	}

	break;

      case M_HISTO_RESET:
	{
	  printf("M_HISTO_RESET %ld pressed\n", parm1);

	  TObject *obj;
	  TIter next1(SubSystemArray.MakeIterator());
	  obj = next1();
	  while(obj){
	    QwGUISubSystem *entry = (QwGUISubSystem*)obj;
	    entry->SetHistoReset(1);
	    entry->SetHistoAccumulate(0);
	    entry->SetHistoPause(0);
	    obj = next1();
	  }

	  break;
	}
      case M_HISTO_ACCUMULATE:
	{
	  printf("M_HISTO_ACCUMULATE %ld pressed\n", parm1);

	  TObject *obj;
	  TIter next1(SubSystemArray.MakeIterator());
	  obj = next1();
	  while(obj){
	    QwGUISubSystem *entry = (QwGUISubSystem*)obj;
	    entry->SetHistoReset(0);
	    entry->SetHistoAccumulate(1);
	    entry->SetHistoPause(0);
	    obj = next1();
	  }

	  break;
	}
      case M_HISTO_PAUSE:
	{
	  printf("M_HISTO_PAUSE %ld pressed\n", parm1);

	  TObject *obj;
	  TIter next1(SubSystemArray.MakeIterator());
	  obj = next1();
	  while(obj){
	    QwGUISubSystem *entry = (QwGUISubSystem*)obj;
	    entry->SetHistoReset(0);
	    entry->SetHistoAccumulate(1);
	    entry->SetHistoPause(1);
	    obj = next1();
	  }


	  break;
	}
      case M_FILE_EXIT:
	{
	  gApplication->Terminate(0);
	}
	break;
      default:
	break;
      }

    default:
      break;
    }

  default:
    break;
  }

  return kTRUE;
}


QwGUIMain *gViewMain;


Int_t main(Int_t argc, Char_t **argv)
{
  Char_t expl[5000];
  ClineArgs dClArgs = {0};
  Int_t help = 0;
  dClArgs.realtime = kFalse;
  dClArgs.checkmode = kFalse;
//   int ax,ay;
//   unsigned int aw, ah;

  if(argv[1]){
    for(Int_t i=1; i < argc; i++){
      if(strcmp(argv[i],"-r")==0){
	dClArgs.realtime = kTrue;
      }

      if(strcmp(argv[i],"-cm")==0){
	dClArgs.checkmode = kTrue;
      }

      if(strcmp(argv[i],"-b")==0){
// 	dClArgs.bin = kTrue;
// 	dClArgs.txt = kFalse;
      }

      if(strcmp(argv[i],"-t")==0){
// 	dClArgs.bin = kFalse;
// 	dClArgs.txt = kTrue;
      }
      if(strcmp(argv[i],"-d")==0){
	dClArgs.detectormap =kTRUE;
	if(argv[i+1]!=NULL){
	  strcpy(dClArgs.file,argv[i+1]);
	  i++;
	}
	else{
	  printf("\n -d provided with no detector map file, exit the program \n Enter the detector map file!  \n\n");
	  exit(1);//if the option -d provided with no detector map file, exit the program
	}

      } 

      if(strcmp(argv[i],"-help")==0){
	
	help = 1;
      }

      if(strcmp(argv[i],"-f")==0){
	if(!argv[i+1] || argv[i+1][0] == '-'){
	  printf("\nMissing value for option -f\n\n");
	  return 0;
	}
// 	strcpy(dClArgs.file,argv[i+1]);
      }

      if(strcmp(argv[i],"-c")==0){
	if(!argv[i+1] || argv[i+1][0] == '-'){
	  printf("\nMissing value for option -c\n\n");
	  return 0;
	}
// 	dClArgs.clmns = atoi(argv[i+1]);
// 	printf("Selected Columns = %d\n",dClArgs.clmns);
      }
    }
  }
  else
    printf("\nRun ""QwGUIData -help"" for command line help\n\n");

  if(help){
    strcpy(expl,"\n\nThis program takes the following commandline arguments:\n\n");
    strcat(expl,"1) -b        Read binary format file.\n\n");
    strcat(expl,"2) -t        Read ascii text file in row and column format.\n\n");
    strcat(expl,"3) -f        Starting filename:\n\n");
    strcat(expl,"             Here one of two file types must be used, based on\n");
    strcat(expl,"             the -b or -t parameters passed .\n");
    strcat(expl,"             For case -b, the program expects a\n");
    strcat(expl,"             a binary file with format to be specified\n");
    strcat(expl,"             For case -t, it expects an ascii file \n");
    strcat(expl,"             arranged in rows and columns of data.\n");
    strcat(expl,"             For the second case, the columns of interest must\n");
    strcat(expl,"             be specified with the -c switch (see below).\n");
    strcat(expl,"             Always use the full path for the input files.\n\n");
    strcat(expl,"4) -c        Columns. Ex: (-c 23) selects columns 2 and 3.\n\n");
    strcat(expl,"5) -d        Enter the custom map file to decode channel map files\n\n");
    strcat(expl,"9) -help     Prints this help \n\n");
    
    printf("%s",expl);
  }
  else{

    //TApplication theApp("QwGUIData", &argc, argv);
    TApplication theApp("QwRealTimeGUI", &argc, argv);

    gROOT->SetStyle("Plain");

    if (gROOT->IsBatch()) {
      fprintf(stderr, "%s: cannot run in batch mode\n", argv[0]);
      return 1;
    }

    QwGUIMain mainWindow(gClient->GetRoot(), dClArgs, 800,600);

    gViewMain = &mainWindow;

    theApp.Run();
  }

  return 0;
}

