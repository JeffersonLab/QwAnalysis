/*------------------------------------------------------------------------*//*!

 \defgroup QwGUIMain QwGUIMain

 \section myoverview Overview of the Qweak analysis GUI frontend
    This group of classes is meant to implement a basic GUI frontend with
    a tab environment for each major subsystem, which, for the moment, will
    read the ROOT file generated by the main analysis program.

    The GUI is based on ROOT classes and a set of utility classes contained
    in a library called QwGUIRootLib-vers.a, where "vers" is the current
    subversion assigned version of the overall QwAnalyzer software.

    Things are meant to be prepared in such a way, as to make it easy for
    other people to implement their own sub system specific data display.
    One can follow the implementation of the main detector subsystem as an
    example.

*//*-------------------------------------------------------------------------*/


/*------------------------------------------------------------------------*//*!

 \file QwGUIMain.cc
 \author Michael Gericke

 \brief main(...) function and MainFrame class for the QwGUI executable




*//*-------------------------------------------------------------------------*/

#include "QwGUIMain.h"

const Int_t QwGUIMain::kMaxMapFileSize = 0x20000000; // 512 MiB


QwGUIMain::QwGUIMain(const TGWindow *p, ClineArgs clargs, UInt_t w, UInt_t h)
  : TGMainFrame(p, w, h), dMWWidth(w), dMWHeight(h), dClArgs(clargs)
{

   ///  First, fill the search paths for the parameter files; this sets a
  ///  static variable within the QwParameterFile class which will be used by
  ///  all instances.
  ///  The "scratch" directory should be first.
  QwParameterFile::AppendToSearchPath(getenv_safe_string("QW_PRMINPUT"));
  QwParameterFile::AppendToSearchPath(getenv_safe_string("QWANALYSIS") + "/Parity/prminput");
  QwParameterFile::AppendToSearchPath(getenv_safe_string("QWANALYSIS") + "/Analysis/prminput");

  //  std::set_new_handler(0);

  MainDetSubSystem      = NULL;
  LumiDetSubSystem      = NULL;
  InjectorSubSystem     = NULL;
  CorrelationSubSystem  = NULL;
  HallCBeamlineSubSystem = NULL;

  dCurRun               = 0;
  MCnt                  = 0;

  dProcessing           = false;
  dProcessHalt          = false;

 
  
  dMapFileOpen          = false;
  dRunOpen              = false;

  //  dROOTFile             = NULL;
  dMemoryMapFile        = NULL;

  dTBinEntry            = NULL;
  dTBinEntryLayout      = NULL;
  dRunEntry             = NULL;
  dRunEntryLayout       = NULL;
  dHorizontal3DLine     = NULL;
  dUtilityFrame         = NULL;
  dUtilityLayout        = NULL;

  dTab                  = NULL;
  dTabLayout            = NULL;

  dMainCanvas           = NULL;
  dMainCnvFrame         = NULL;
  dMainTabFrame         = NULL;
  dMainTabLayout        = NULL;
  dMainCnvLayout        = NULL;

  dLogEdit              = NULL;
  dLogTabFrame          = NULL;
  dLogTabLayout         = NULL;
  dLogEditLayout        = NULL;


  dMenuBar              = NULL;
  dMenuTabs             = NULL;
  dMenuLoadMap          = NULL;
  dMenuHistoState       = NULL;
  dMenuBarLayout        = NULL;
  dMenuBarItemLayout    = NULL;

  MakeMenuLayout();
  MakeMainTab();

  SetWindowName("Qweak RealTime Data Analysis GUI");


  MapSubwindows();
  Resize(GetDefaultSize());
  MapWindow();

  if (dClArgs.detectormap==kTRUE){
    printf("custom detector map included - %s \n",dClArgs.file);
    strcpy(dDetMapFile,dClArgs.file);
  }
  else{
     strcpy(dDetMapFile,"detectors.map");
  }

  LoadChannelMapFiles(dDetMapFile);//loads the channel map files for all the subsystems

  if(!GetSubSystemPtr("Main Detectors") && dMDChannelMap.Length()){
    MainDetSubSystem = new QwGUIMainDetector(fClient->GetRoot(), this, dTab,"Main Detectors",
					     "QwGUIMain", dMWWidth-15,dMWHeight-180);
    MainDetSubSystem->LoadHistoMapFile(dMDChannelMap);
  }
  if(!GetSubSystemPtr("Lumi Detectors") && dLumiChannelMap.Length()){
    LumiDetSubSystem = new QwGUILumiDetector(fClient->GetRoot(), this, dTab,"Lumi Detectors",
					     "QwGUIMain", dMWWidth-15,dMWHeight-180);
    LumiDetSubSystem->LoadHistoMapFile(dLumiChannelMap);
  }
  if(!GetSubSystemPtr("Injector")&& dInjectorChannelMap.Length()){
    InjectorSubSystem = new QwGUIInjector(fClient->GetRoot(), this, dTab,"Injector",
					  "QwGUIMain", dMWWidth-15,dMWHeight-180);
    InjectorSubSystem->LoadHistoMapFile(dInjectorChannelMap);
  }

  if(!GetSubSystemPtr("HallC Beamline") && dHallCChannelMap.Length()){
    HallCBeamlineSubSystem = new QwGUIHallCBeamline(fClient->GetRoot(), this, dTab,"HallC Beamline",
					  "QwGUIMain", dMWWidth-15,dMWHeight-180);
    HallCBeamlineSubSystem->LoadHistoMapFile(dHallCChannelMap);
  }
  
  if(!GetSubSystemPtr("Correlation Plots")) {
    CorrelationSubSystem = new QwGUICorrelationPlots(fClient->GetRoot(), this, dTab,"Correlation Plots",
						     "QwGUIMain", dMWWidth-15,dMWHeight-180);
  }
  
};

QwGUIMain::~QwGUIMain()
{
  delete MainDetSubSystem      ;
  delete LumiDetSubSystem      ;
  delete InjectorSubSystem     ;
  delete CorrelationSubSystem  ;
  delete HallCBeamlineSubSystem;

  delete dTBinEntry            ;
  delete dTBinEntryLayout      ;
  delete dRunEntry             ;
  delete dRunEntryLayout       ;
  delete dUtilityFrame         ;
  delete dUtilityLayout        ;

  delete dTab                  ;
  delete dTabLayout            ;

  delete dMainCanvas           ;
  delete dMainCnvFrame         ;
  delete dMainTabFrame         ;
  delete dMainTabLayout        ;
  delete dMainCnvLayout        ;

  delete dLogEdit              ;
  delete dLogTabFrame          ;
  delete dLogTabLayout         ;
  delete dLogEditLayout        ;


  delete dMenuBar              ;
  delete dMenuTabs             ;
  delete dMenuBarLayout        ;
  delete dMenuBarItemLayout    ;
  delete dMenuLoadMap          ;

}

void QwGUIMain::LoadChannelMapFiles(TString detfile)
{
  TString varname, varvalue;
  TString subsysname,subsysmapname;
  QwParameterFile mapstr(detfile.Data());  //Open the file
  TString subsystemname;
  QwParameterFile *section;
  dMDChannelMap="";
  dHallCChannelMap="";
  dInjectorChannelMap="";
  dLumiChannelMap="";

  std::cout << "Adding ............ " << std::endl;
  Int_t output_width = 40;

  while ( (section=mapstr.ReadNextSection(subsystemname)) )
    {
      while (section->ReadNextLine())
	{
	  section->TrimComment('#');   // Remove everything after a '#' character.
	  section->TrimWhitespace();   // Get rid of leading and trailing spaces.
	  if (section->LineIsEmpty())  continue;
	  if (section->HasVariablePair("=",varname,varvalue)){
	    varname.ToLower();
	    if (varname=="name")
	      subsysname=varvalue;
	    else if (varname=="map")
	      subsysmapname=varvalue;
	  }
	}
      if (subsystemname=="QwBeamLine"){//we have hallc and injector beamlines
	subsysname.ToLower();
	if (subsysname.Contains("hallc") || subsysname.Contains("hall c")) {
	  dHallCChannelMap=subsysmapname;
	  std::cout << std::setw(output_width) << dHallCChannelMap << "\n";
	}
	else if (subsysname.Contains("injector")) {
	  dInjectorChannelMap=subsysmapname;
	  std::cout << std::setw(output_width) << dInjectorChannelMap << "\n";
	}
      }
      else if (subsystemname=="QwMainCerenkovDetector"){
	dMDChannelMap=subsysmapname;
	std::cout << std::setw(output_width) << dMDChannelMap << "\n";
      }
      else if (subsystemname=="QwLumi"){
	dLumiChannelMap=subsysmapname;
	std::cout << std::setw(output_width) << dLumiChannelMap  << "\n";
      }//add any other subsystem included in RT
      
      // std::cout << std::setw(30) << subsystemname
      // 		<< " "
      // 		<< std::setw(30) << subsysmapname
      // 		<< std::endl;
    }
  std::cout  << std::setw(Int_t(1.8*output_width)) << ".............. to QwRealTimeGUI " << std::endl;

};

void QwGUIMain::MakeMenuLayout()
{
  dMenuBarLayout = new TGLayoutHints(kLHintsTop | kLHintsLeft | kLHintsExpandX,
				     0, 0, 1, 1);
  dMenuBarItemLayout = new TGLayoutHints(kLHintsTop | kLHintsLeft, 0, 4, 0, 0);
  
  dMenuLoadMap = new TGPopupMenu(fClient->GetRoot());
  dMenuLoadMap->AddEntry("Load Memory", M_VIEW_MAPLOAD); 
  dMenuLoadMap->AddSeparator();
  dMenuLoadMap->AddEntry("Exit",  M_FILE_EXIT);

  dMenuHistoState = new TGPopupMenu(fClient->GetRoot());
  dMenuHistoState->AddEntry("Reset Histos", M_HISTO_RESET); 
  dMenuHistoState->AddSeparator();
  dMenuHistoState->AddEntry("Accumulate Histos",   M_HISTO_ACCUMULATE);
  dMenuHistoState->AddSeparator();
  dMenuHistoState->AddEntry("Pause Histos",   M_HISTO_PAUSE);

  

  dMenuTabs = new TGPopupMenu(fClient->GetRoot());
  dMenuTabs->AddEntry("View Log", M_VIEW_LOG);
  
  // dMenuTabs->Associate(this);
  dMenuLoadMap->Associate(this);
  dMenuHistoState->Associate(this);
 

  dMenuBar = new TGMenuBar(this, 1, 1, kHorizontalFrame);
  dMenuBar->AddPopup("&MemoryMap", dMenuLoadMap, dMenuBarItemLayout);
  dMenuBar->AddPopup("H&istograms", dMenuHistoState, dMenuBarItemLayout);
  // dMenuBar->AddPopup("&Tabs", dMenuTabs, dMenuBarItemLayout);

  AddFrame(dMenuBar, dMenuBarLayout);
  //  dMenuTabs->CheckEntry(M_VIEW_LOG);
}


void QwGUIMain::MakeMainTab()
{

  dTabLayout = new TGLayoutHints(kLHintsBottom | kLHintsExpandX | kLHintsExpandY,
				 2, 2, 5, 1);
  dTab = new TGTab(this,dMWWidth-15,dMWHeight-80);

  if(TabActive("Main")) return;

  dMainTabLayout = new TGLayoutHints(kLHintsLeft | kLHintsTop |
				     kLHintsExpandX | kLHintsExpandY);
  dMainCnvLayout = new TGLayoutHints(kLHintsTop | kLHintsExpandX | kLHintsExpandY,
				     0, 0, 1, 2);

  TGCompositeFrame *tf = dTab->AddTab("Main");

  dMainTabFrame = new TGHorizontalFrame(tf,10,10);
  dMainCanvas   = new TRootEmbeddedCanvas("pC", dMainTabFrame,10, 10);
  dMainTabFrame->AddFrame(dMainCanvas,dMainCnvLayout);
  dMainTabFrame->Resize(dMWWidth-15,dMWHeight-110);
  tf->AddFrame(dMainTabFrame,dMainTabLayout);
  AddFrame(dTab, dTabLayout);

  dMainCanvas->GetCanvas()->SetBorderMode(0);
  dMainCanvas->GetCanvas()->Connect("ProcessedEvent(Int_t,Int_t,Int_t,TObject*)",
				    "QwGUIMain",
				    this,"MainTabEvent(Int_t,Int_t,Int_t,TObject*)");
}

void QwGUIMain::MakeLogTab()
{

}

void QwGUIMain::RemoveTab(QwGUISubSystem* sbSystem)
{
  if(!sbSystem) return;
  const char *TabName = sbSystem->GetName();
  if(!TabActive(TabName)) return;
  int tab = GetTabIndex(TabName);
  if(tab < 0) return;

  dMenuTabs->UnCheckEntry(GetTabMenuID(TabName));
  sbSystem->TabMenuEntryChecked(kFalse);
  UnMapLayout(tab);
}

void QwGUIMain::AddATab(QwGUISubSystem* sbSystem)
{
  if(!dMenuTabs) return;
  if(!sbSystem) return;

  int flag = 0;
  TString s = sbSystem->GetName();
  TObject *obj;
  TIter next(dMenuTabs->GetListOfEntries());

  obj = next();
  while(obj){
    TGMenuEntry *entry = (TGMenuEntry*)obj;
    //       printf("%s %d\n",entry->GetLabel()->GetString(),entry->GetEntryId());
    if(s == entry->GetLabel()->GetString()){
      flag = 1;
      break;
    }
    obj = next();
  }

  if(!flag){
    Long_t mID = GetNewTabMenuID();
    dMenuTabs->AddEntry(s,mID);
    sbSystem->SetTabMenuID(mID);
    SubSystemArray.Add(sbSystem);
    sbSystem->SubSystemLayout();
  }

  if(TabActive(s.Data())) return;

  dTab->AddTab(s.Data(),sbSystem);
  dMenuTabs->CheckEntry(GetTabMenuID(s.Data()));
  sbSystem->TabMenuEntryChecked(kTrue);
  MapLayout();
}

Int_t QwGUIMain::GetTabMenuID(const char* TabName)
{
  if(!dMenuTabs) return 0;

  TString s = TabName;
  TObject *obj;
  TIter next(dMenuTabs->GetListOfEntries());

  obj = next();
  while(obj){
    TGMenuEntry *entry = (TGMenuEntry*)obj;
    //       printf("%s %d\n",entry->GetLabel()->GetString(),entry->GetEntryId());
    if(s == entry->GetLabel()->GetString()) return entry->GetEntryId();
    obj = next();
  }

  return 0;
}

const char* QwGUIMain::GetTabMenuLabel(Long_t mID)
{
  if(!dMenuTabs) return 0;

  TString s;
  TObject *obj;
  TIter next(dMenuTabs->GetListOfEntries());

  obj = next();
  while(obj){
    TGMenuEntry *entry = (TGMenuEntry*)obj;
    //       printf("%s %d\n",entry->GetLabel()->GetString(),entry->GetEntryId());
    if(mID == entry->GetEntryId()) {
      s = entry->GetLabel()->GetString();
      return s.Data();
    }
    obj = next();
  }

  return 0;
}


Bool_t QwGUIMain::TabActive(const char *str)
{
  int nt = dTab->GetNumberOfTabs();
  for (int i = 0 ; i < nt; i++) {
    TString s = dTab->GetTabTab(i)->GetString();
    if (s == str) {return kTrue;}
  }
  return kFalse;
}

Int_t QwGUIMain::GetTabIndex(const char *str)
{
  TString s;
  TString label = str;
  int nt = dTab->GetNumberOfTabs();
  for (int i = 0 ; i < nt; i++) {
    s = dTab->GetTabTab(i)->GetString();
    if (s == label) {return i;}
  }
  return -1;
}

void QwGUIMain::MainTabEvent(Int_t event, Int_t x, Int_t y, TObject* selobject)
{
//   if(event == kButton1Double){
//     Int_t pad = dMainCanvas->GetCanvas()->GetSelectedPad()->GetNumber();
//   }
}


// Wait, but continue to process events.
void QwGUIMain::SleepWithEvents(int seconds)
{
  time_t start, now;
  time(&start);
  do {
    time(&now);
    gSystem->ProcessEvents();
  } while (difftime(now,start) < seconds) ;
}

QwGUISubSystem *QwGUIMain::GetSubSystemPtr(const char *name)
{

  TObject *obj;
  TIter next(SubSystemArray.MakeIterator());
  obj = next();
  while(obj){
    QwGUISubSystem *entry = (QwGUISubSystem*)obj;
    if(!strcmp(name,entry->GetName())){
      return entry;
    }
    obj = next();
  }

  return 0;

}

// void QwGUIMain::PlotMainData(ERPlotTypes ptype)
// {
// }

void QwGUIMain::OnLogMessage(const char *msg)
{
  // Append(msg,kFalse);
}

void QwGUIMain::OnObjClose(const char *objname)
{
  if(!objname) return;

//   TString name = objname;

//   if(name.Contains("dROOTFile")){
//     dROOTFile = NULL;
// #ifdef QWGUI_DEBUG
//     printf("Received dROOTFile IsClosing signal\n");
// #endif
//  }

//   TObject *obj;
//   TIter next(SubSystemArray.MakeIterator());
//   obj = next();
//   while(obj){
//     QwGUISubSystem *entry = (QwGUISubSystem*)obj;
//     if(!strcmp(objname,entry->GetName())){
//       SubSystemArray.Remove(entry);
//     }
//     obj = next();
//   }
}

void QwGUIMain::OnReceiveMessage(const char *obj)
{
}



Bool_t QwGUIMain::OpenMapFile()
{

  this-> CloseMapFile();

  TString mapfilename = gSystem->Getenv("QW_ROOTFILES");
  mapfilename += "/QwMemMapFile.map";


  // hmmm, strange, I cannot catch any error here, 
  // Segmentation fault by using whatever....
  // Friday, October 29 16:19:35 EDT 2010, jhlee


  // try 
  //   {
  //  printf("Reading %s\n", mapfilename.Data());
  //   new TMapFile(mapfilename, "", "READ", kMaxMapFileSize , dMemoryMapFile); // protected..
  //   dMemoryMapFile = TMapFile::Create(mapfilename, "READ",  kMaxMapFileSize, ""); //// default is "read"
  dMemoryMapFile = TMapFile::Create(mapfilename);
  //   }
  // catch  (std::exception& e)
  //   {
  //     std::cerr << "exception caught: " << e.what() << std::endl;
  //   }
  
  if ((dMemoryMapFile->IsOnHeap()) && not (dMemoryMapFile->IsZombie()) ) {
    //    printf("===== QwRealTimeGUI Reads the RealTime Producer Memory Map File ======\n");
    //    std::cout << dMemoryMapFile << std::endl;
    dMemoryMapFile->Print();
    dMapFileOpen = true;
    //    printf("======================================================================\n");
  
  }
  else {
    std::cout << "The shared memory region mapped to a file"
	      << mapfilename
	      << " could not be opened." << std::endl;
    dMapFileOpen = false;
  }

  if (dMapFileOpen) {
    TObject *obj;
    TIter next(SubSystemArray.MakeIterator());
    obj = next();
    
    while(obj){
      QwGUISubSystem *entry = (QwGUISubSystem*)obj;
      entry->SetMapFile(dMemoryMapFile);
      obj = next();
    }
    
  }
  
  return dMapFileOpen;
};



void QwGUIMain::CloseMapFile()
{
  if (IsMapFileOpen()) {
    TString name = dMemoryMapFile->GetName();
    std::cout << "The memory file " << name
	      << " at the address " 
	      << dMemoryMapFile 
	      << " is closing now."
	      << std::endl;
    dMemoryMapFile->Close();
    dMemoryMapFile = NULL;
  }
  else {
    dMemoryMapFile = NULL;
  }
  dMapFileOpen = false;
}

void QwGUIMain::CloseWindow()
{
  this->CloseMapFile();
  gApplication->Terminate(0);

}

Bool_t QwGUIMain::ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2)
{
  // Handle messages send to the MainFrame object. E.g. all menu button
  // messages.

  Long_t mTabID = 0;
  //printf("\n ProcessMessage 1\n");
  switch (GET_MSG(msg)){

  case kC_TEXTENTRY:
    switch (GET_SUBMSG(msg)) {
    case kTE_ENTER:
      switch (parm1) {

      case M_RUN_SELECT:
	break;

      default:
	break;
      }

    default:
      break;
    }

  case kC_COMMAND:
    switch (GET_SUBMSG(msg)) {

    case kCM_COMBOBOX:
      {
	switch (parm1) {
	case M_TBIN_SELECT:
	  break;
	}
      }
      break;

    case kCM_MENUSELECT:
      break;

    case kCM_MENU:

      for(int n = M_TABS; n <= M_TABS+MCnt; n++ ){
	mTabID = n;
	if(parm1 == mTabID){

	  if(dMenuTabs->IsEntryChecked(mTabID)){
	    RemoveTab((QwGUISubSystem*)dTab->GetTabContainer(GetTabIndex(GetTabMenuLabel(mTabID))));
	  }
	  else{

	    TObject *obj;
	    TIter next(SubSystemArray.MakeIterator());
	    obj = next();
	    while(obj){
	      QwGUISubSystem *entry = (QwGUISubSystem*)obj;
	      if(!strcmp(GetTabMenuLabel(mTabID),entry->GetName()))
		AddATab(entry);
	      obj = next();
	    }
	  }

	  break;
	}
      }
      //printf("\n ProcessMessage 1\n");
      switch (parm1) {

      case M_VIEW_LOG:
	// if(dMenuTabs->IsEntryChecked(M_VIEW_LOG)){
	//   RemoveLogTab();
	// }
	// else{
	//   MakeLogTab();
	// }
	break;

      case M_VIEW_MAPLOAD:
	//	printf("\n Loading Memory \n");
	try 
	  {
	    OpenMapFile();
	  }
	catch (std::exception& e)
	  {
	    std::cerr << "exception caught: " << e.what() << std::endl;
	  }
	break;

      case M_HISTO_RESET:
	{
	  //	  printf("M_HISTO_RESET %ld pressed\n", parm1);

	  TObject *obj;
	  TIter next1(SubSystemArray.MakeIterator());
	  obj = next1();
	  while(obj){
	    QwGUISubSystem *entry = (QwGUISubSystem*)obj;
	    entry->SetHistoReset(1);
	    entry->SetHistoAccumulate(0);
	    entry->SetHistoPause(0);
	    obj = next1();
	  }

	  break;
	}
      case M_HISTO_ACCUMULATE:
	{
	  //	  printf("M_HISTO_ACCUMULATE %ld pressed\n", parm1);

	  TObject *obj;
	  TIter next1(SubSystemArray.MakeIterator());
	  obj = next1();
	  while(obj){
	    QwGUISubSystem *entry = (QwGUISubSystem*)obj;
	    entry->SetHistoReset(0);
	    entry->SetHistoAccumulate(1);
	    entry->SetHistoPause(0);
	    obj = next1();
	  }

	  break;
	}
      case M_HISTO_PAUSE:
	{
	  //	  printf("M_HISTO_PAUSE %ld pressed\n", parm1);

	  TObject *obj;
	  TIter next1(SubSystemArray.MakeIterator());
	  obj = next1();
	  while(obj){
	    QwGUISubSystem *entry = (QwGUISubSystem*)obj;
	    entry->SetHistoReset(0);
	    entry->SetHistoAccumulate(1);
	    entry->SetHistoPause(1);
	    obj = next1();
	  }


	  break;
	}
      case M_FILE_EXIT:
	{
	  this->CloseWindow();
	}
	break;
      default:
	break;
      }

    default:
      break;
    }

  default:
    break;
  }

  return kTRUE;
}



Int_t main(Int_t argc, Char_t **argv)
{
  ClineArgs dClArgs = {0};

  dClArgs.realtime = kFalse;
  dClArgs.checkmode = kFalse;
  
  if(argv[1]){
    for(Int_t i=1; i < argc; i++){
      if(strcmp(argv[i],"-r")==0){
	dClArgs.realtime = kTrue;
      }

      if(strcmp(argv[i],"-cm")==0){
	dClArgs.checkmode = kTrue;
      }

      if(strcmp(argv[i],"-b")==0){
// 	dClArgs.bin = kTrue;
// 	dClArgs.txt = kFalse;
      }

      if(strcmp(argv[i],"-t")==0){
// 	dClArgs.bin = kFalse;
// 	dClArgs.txt = kTrue;
      }
      if(strcmp(argv[i],"-d")==0){
	dClArgs.detectormap =kTRUE;
	if(argv[i+1]!=NULL){
	  strcpy(dClArgs.file,argv[i+1]);
	  i++;
	}
	else{
	  printf("\n -d provided with no detector map file, exit the program \n Enter the detector map file!  \n\n");
	  exit(1);//if the option -d provided with no detector map file, exit the program
	}

      } 

      if(strcmp(argv[i],"-f")==0){
	if(!argv[i+1] || argv[i+1][0] == '-'){
	  printf("\nMissing value for option -f\n\n");
	  return 0;
	}
// 	strcpy(dClArgs.file,argv[i+1]);
      }

      if(strcmp(argv[i],"-c")==0){
	if(!argv[i+1] || argv[i+1][0] == '-'){
	  printf("\nMissing value for option -c\n\n");
	  return 0;
	}
// 	dClArgs.clmns = atoi(argv[i+1]);
// 	printf("Selected Columns = %d\n",dClArgs.clmns);
      }
    }
  }

  TApplication theApp("QwRealTimeGUI", &argc, argv, 0, 0);
  gROOT->SetStyle("Plain");
  if (gROOT->IsBatch()) {
    fprintf(stderr, "%s: cannot run in batch mode\n", argv[0]);
    return 1;
  }
  QwGUIMain mainWindow(gClient->GetRoot(), dClArgs, 800,600);
  theApp.Run();

  return 0;
}

