/*------------------------------------------------------------------------*//*!

 \defgroup QwGUIMain QwGUIMain

 \section myoverview Overview of the Qweak analysis GUI frontend
    This group of classes is meant to implement a basic GUI frontend with
    a tab environment for each major subsystem, which, for the moment, will
    read the ROOT file generated by the main analysis program.

    The GUI is based on ROOT classes and a set of utility classes contained
    in a library called QwGUIRootLib-vers.a, where "vers" is the current
    subversion assigned version of the overall QwAnalyzer software.

    Things are meant to be prepared in such a way, as to make it easy for
    other people to implement their own sub system specific data display.
    One can follow the implementation of the main detector subsystem as an
    example.

*//*-------------------------------------------------------------------------*/


/*------------------------------------------------------------------------*//*!

 \file QwGUIMain.cc
 \author Michael Gericke

 \brief main(...) function and MainFrame class for the QwGUI executable




*//*-------------------------------------------------------------------------*/

#include "QwGUIMain.h"

//const Int_t QwGUIMain::kMaxMapFileSize = 0x20000000; // 512 MiB
const Int_t QwGUIMain::kMaxMapFileSize = 0x10000000; // 256 MiB
//const Int_t QwGUIMain::kCharLength = 127;

QwGUIMain::QwGUIMain(const TGWindow *p, ClineArgs clargs, UInt_t w, UInt_t h)
  : TGMainFrame(p, w, h), dMWWidth(w), dMWHeight(h), dClArgs(clargs)
{

   ///  First, fill the search paths for the parameter files; this sets a
  ///  static variable within the QwParameterFile class which will be used by
  ///  all instances.
  ///  The "scratch" directory should be first.
  QwParameterFile::AppendToSearchPath(getenv_safe_string("QW_PRMINPUT"));
  QwParameterFile::AppendToSearchPath(getenv_safe_string("QWANALYSIS") + "/Parity/prminput");
  QwParameterFile::AppendToSearchPath(getenv_safe_string("QWANALYSIS") + "/Analysis/prminput");

  //  std::set_new_handler(0);

  MainDetSubSystem      = NULL;
  LumiDetSubSystem      = NULL;
  InjectorSubSystem     = NULL;
  CorrelationSubSystem  = NULL;
  HallCBeamlineSubSystem = NULL;
  SummaryTab             = NULL;
  dCurRun               = 0;
  MCnt                  = 0;
  
  dMapFileOpen          = false;
  dRunOpen              = false;
  dRunStopFlag          = false;

  dMemoryMapFile        = NULL;

  dTab                  = NULL;
 
  dMainCanvas           = NULL;
  dMainCnvFrame         = NULL;
  dMainTabFrame         = NULL;
  dMainTabLayout        = NULL;
  dMainCnvLayout        = NULL;

  // dLogEdit              = NULL;
  // dLogTabFrame          = NULL;
  // dLogTabLayout         = NULL;
  // dLogEditLayout        = NULL;


  dMenuBar              = NULL;
  dMenuTabs             = NULL;
  dMenuLoadMap          = NULL;
  dMenuHistoState       = NULL;
  dMenuBarLayout        = NULL;
  dMenuBarItemLayout    = NULL;

  
  dtxtEntries           = NULL;

  MakeMenuLayout();


  gClient->GetColorByName("green", green);
  gClient->GetColorByName("red",   red);

  Int_t  ten_percent_height = (Int_t) 0.1*dMWHeight;


  //  dMainButtonsFrame = new  TGHorizontalFrame(this, dMWWidth, ten_percent_height);
  dMainButtonsFrame = new  TGHorizontalFrame(this, dMWWidth, ten_percent_height);

  AddFrame(dMainButtonsFrame,  new TGLayoutHints(kLHintsBottom | kLHintsExpandX, 1,1,1,1));

  dMainButton[0] = new TGTextButton(dMainButtonsFrame, "Load/Unload",  M_LOAD_UNLOAD);
  dMainButton[1] = new TGTextButton(dMainButtonsFrame, "Run/Stop", M_RUN_STOP);
  dMainButton[2] = new TGTextButton(dMainButtonsFrame, "Reset", M_RESET);
  dMainButton[3] = new TGTextButton(dMainButtonsFrame, "Auto-Rest", M_AUTO_RESET);
  dMainButton[4] = new TGTextButton(dMainButtonsFrame, "Exit", M_EXIT);

  dtxtEntries= new TGTextEntry(dMainButtonsFrame,"100000",TXT_ENTRIES);


  
  // reduce "for" in order to get 'ns' faster than...
  
  //Sunday, October 31 02:50:16 EDT 2010, jhlee

  dMainButton[0] -> Associate(this);
  dMainButton[1] -> Associate(this);
  dMainButton[2] -> Associate(this);  
  dMainButton[3] -> Associate(this);
  dMainButton[4] -> Associate(this);
  dtxtEntries -> Associate(this);

  dMainButton[0] -> ChangeBackground(red);
  dMainButton[1] -> SetEnabled(false);
  dMainButton[2] -> SetEnabled(false);
  dMainButton[3] -> SetEnabled(false);

  dMainButtonsFrame -> AddFrame(dMainButton[0], new TGLayoutHints(kLHintsExpandX, 2,2,1,1));
  dMainButtonsFrame -> AddFrame(dMainButton[1], new TGLayoutHints(kLHintsExpandX, 2,2,1,1));
  dMainButtonsFrame -> AddFrame(dMainButton[2], new TGLayoutHints(kLHintsExpandX, 2,2,1,1));
  dMainButtonsFrame -> AddFrame(dMainButton[3], new TGLayoutHints(kLHintsExpandX, 2,2,1,1));
  dMainButtonsFrame -> AddFrame(dtxtEntries, new TGLayoutHints(kLHintsExpandX, 2,2,1,1));
  dMainButtonsFrame -> AddFrame(dMainButton[4], new TGLayoutHints(kLHintsExpandX, 2,2,1,1));



  if (dClArgs.detectormap==kTRUE){
    printf("custom detector map included - %s \n",dClArgs.file);
    dDetMapFile = dClArgs.file;
   }
  else{
    dDetMapFile = "realtime_detectors.map";
  }

  LoadChannelMapFiles(dDetMapFile.Data());//loads the channel map files for all the subsystems

  dTab = new TGTab(this,  dMWWidth, dMWHeight);

  SummaryTab = new QwGUISummary(fClient->GetRoot(), this, dTab,"Summary",
  				"QwGUIMain", dMWWidth-15,dMWHeight-180);
  //SummaryTab->LoadHistoMapFile(dMDChannelMap);

  if(!GetSubSystemPtr("Main Detectors") && dMDChannelMap.Length()){
    MainDetSubSystem = new QwGUIMainDetector(fClient->GetRoot(), this, dTab,"Main Detectors",
					     "QwGUIMain", dMWWidth-15,dMWHeight-180);
    MainDetSubSystem->LoadHistoMapFile(dMDChannelMap);
  }
  if(!GetSubSystemPtr("Lumi Detectors") && dLumiChannelMap.Length()){
    LumiDetSubSystem = new QwGUILumiDetector(fClient->GetRoot(), this, dTab,"Lumi Detectors",
					     "QwGUIMain", dMWWidth-15,dMWHeight-180);
    LumiDetSubSystem->LoadHistoMapFile(dLumiChannelMap);
  }
  if(!GetSubSystemPtr("Injector")&& dInjectorChannelMap.Length()){
    InjectorSubSystem = new QwGUIInjector(fClient->GetRoot(), this, dTab,"Injector",
					  "QwGUIMain", dMWWidth-15,dMWHeight-180);
    InjectorSubSystem->LoadHistoMapFile(dInjectorChannelMap);
  }

  if(!GetSubSystemPtr("HallC Beamline") && dHallCChannelMap.Length()){
    HallCBeamlineSubSystem = new QwGUIHallCBeamline(fClient->GetRoot(), this, dTab,"HallC Beamline",
					  "QwGUIMain", dMWWidth-15,dMWHeight-180);
    HallCBeamlineSubSystem->LoadHistoMapFile(dHallCChannelMap);
  }
  
  if(!GetSubSystemPtr("Correlation Plots")) {
    CorrelationSubSystem = new QwGUICorrelationPlots(fClient->GetRoot(), this, dTab,"Correlation Plots",
						     "QwGUIMain", dMWWidth-15,dMWHeight-180);
  }


  this -> AddFrame(dTab,  new TGLayoutHints(kLHintsExpandX | kLHintsExpandY, 2, 2, 2, 2));
  this -> MapSubwindows();
  this-> Resize(this-> GetDefaultSize()); 
  Layout();
  this -> SetWindowName("Qweak RealTime Data Analysis GUI");
  this -> SetIconName("QwRealTimeGUI");
  this -> MapWindow();  
};

QwGUIMain::~QwGUIMain()
{
  delete MainDetSubSystem      ;
  delete LumiDetSubSystem      ;
  delete InjectorSubSystem     ;
  delete CorrelationSubSystem  ;
  delete HallCBeamlineSubSystem;
  delete SummaryTab            ;
  delete dTab                  ;
 
  delete dMainCanvas           ;
  delete dMainCnvFrame         ;
  delete dMainTabFrame         ;
  delete dMainTabLayout        ;
  delete dMainCnvLayout        ;

  delete dMenuBar              ;
  delete dMenuTabs             ;
  delete dMenuBarLayout        ;
  delete dMenuBarItemLayout    ;
  delete dMenuLoadMap          ;

  delete [] dMainButton;
  delete    dMainButtonsFrame;

  delete dtxtEntries;


}

void QwGUIMain::LoadChannelMapFiles(TString detfile)
{
  TString varname, varvalue;
  TString subsysname,subsysmapname;
  QwParameterFile mapstr(detfile.Data());  //Open the file
  TString subsystemname;
  QwParameterFile *section;
  dMDChannelMap="";
  dHallCChannelMap="";
  dInjectorChannelMap="";
  dLumiChannelMap="";

  std::cout << "Adding ............ " << std::endl;
  Int_t output_width = 40;

  while ( (section=mapstr.ReadNextSection(subsystemname)) )
    {
      while (section->ReadNextLine())
	{
	  section->TrimComment('#');   // Remove everything after a '#' character.
	  section->TrimWhitespace();   // Get rid of leading and trailing spaces.
	  if (section->LineIsEmpty())  continue;
	  if (section->HasVariablePair("=",varname,varvalue)){
	    varname.ToLower();
	    if (varname=="name")
	      subsysname=varvalue;
	    else if (varname=="map")
	      subsysmapname=varvalue;
	  }
	}
      if (subsystemname=="QwBeamLine"){//we have hallc and injector beamlines
	subsysname.ToLower();
	if (subsysname.Contains("hallc") || subsysname.Contains("hall c")) {
	  dHallCChannelMap=subsysmapname;
	  std::cout << std::setw(output_width) << dHallCChannelMap << "\n";
	}
	else if (subsysname.Contains("injector")) {
	  dInjectorChannelMap=subsysmapname;
	  std::cout << std::setw(output_width) << dInjectorChannelMap << "\n";
	}
      }
      else if (subsystemname=="QwMainCerenkovDetector"){
	dMDChannelMap=subsysmapname;
	std::cout << std::setw(output_width) << dMDChannelMap << "\n";
      }
      else if (subsystemname=="QwLumi"){
	dLumiChannelMap=subsysmapname;
	std::cout << std::setw(output_width) << dLumiChannelMap  << "\n";
      }//add any other subsystem included in RT
      
      // std::cout << std::setw(30) << subsystemname
      // 		<< " "
      // 		<< std::setw(30) << subsysmapname
      // 		<< std::endl;
    }
  std::cout  << std::setw(Int_t(1.8*output_width)) << ".............. to QwRealTimeGUI " << std::endl;

};

void QwGUIMain::MakeMenuLayout()
{
  dMenuBarLayout = new TGLayoutHints(kLHintsTop | kLHintsLeft | kLHintsExpandX,
				     0, 0, 1, 1);
  dMenuBarItemLayout = new TGLayoutHints(kLHintsTop | kLHintsLeft, 0, 4, 0, 0);
  
  dMenuLoadMap = new TGPopupMenu(fClient->GetRoot());
  dMenuLoadMap->AddEntry("Load Memory", M_VIEW_MAPLOAD); 
  dMenuLoadMap->AddSeparator();
  dMenuLoadMap->AddEntry("Exit",  M_FILE_EXIT);

  dMenuHistoState = new TGPopupMenu(fClient->GetRoot());
  dMenuHistoState->AddEntry("Reset Histos", M_HISTO_RESET); 
  dMenuHistoState->AddSeparator();
  dMenuHistoState->AddEntry("Accumulate Histos",   M_HISTO_ACCUMULATE);
  dMenuHistoState->AddSeparator();
  dMenuHistoState->AddEntry("Pause Histos",   M_HISTO_PAUSE);

  

  dMenuTabs = new TGPopupMenu(fClient->GetRoot());
  // dMenuTabs->AddEntry("View Log", M_VIEW_LOG);
  
  // dMenuTabs->Associate(this);
  dMenuLoadMap->Associate(this);
  dMenuHistoState->Associate(this);
 

  dMenuBar = new TGMenuBar(this, 1, 1, kHorizontalFrame);
  dMenuBar->AddPopup("&MemoryMap", dMenuLoadMap, dMenuBarItemLayout);
  dMenuBar->AddPopup("H&istograms", dMenuHistoState, dMenuBarItemLayout);
  // dMenuBar->AddPopup("&Tabs", dMenuTabs, dMenuBarItemLayout);

  AddFrame(dMenuBar, dMenuBarLayout);
  //  dMenuTabs->CheckEntry(M_VIEW_LOG);
}

void QwGUIMain::AddATab(QwGUISubSystem* sbSystem)
{
  if(!dMenuTabs) return;
  if(!sbSystem) return;

  int flag = 0;
  TString s = sbSystem->GetName();
  TObject *obj;
  TIter next(dMenuTabs->GetListOfEntries());

  obj = next();
  while(obj){
    TGMenuEntry *entry = (TGMenuEntry*)obj;
    //       printf("%s %d\n",entry->GetLabel()->GetString(),entry->GetEntryId());
    if(s == entry->GetLabel()->GetString()){
      flag = 1;
      break;
    }
    obj = next();
  }

  if(!flag){
    Long_t mID = GetNewTabMenuID();
    dMenuTabs->AddEntry(s,mID);
    sbSystem->SetTabMenuID(mID);
    SubSystemArray.Add(sbSystem);
    sbSystem->SubSystemLayout();
  }

  if(TabActive(s.Data())) return;

  dTab->AddTab(s.Data(),sbSystem);
  dMenuTabs->CheckEntry(GetTabMenuID(s.Data()));
  // sbSystem->TabMenuEntryChecked(kTRUE);
  ((TGTabElement*)(dTab->GetTabTab("Summary Tab")))->SetActive();
  MapLayout();
  return;
}

Int_t QwGUIMain::GetTabMenuID(const char* TabName)
{
  if(!dMenuTabs) return 0;

  TString s = TabName;
  TObject *obj;
  TIter next(dMenuTabs->GetListOfEntries());

  obj = next();
  while(obj){
    TGMenuEntry *entry = (TGMenuEntry*)obj;
    //printf("%s %d\n",entry->GetLabel()->GetString(),entry->GetEntryId());
    if(s == entry->GetLabel()->GetString()) return entry->GetEntryId();
    obj = next();
  }

  return 0;
}

const char* QwGUIMain::GetTabMenuLabel(Long_t mID)
{
  if(!dMenuTabs) return 0;

  TString s;
  TObject *obj;
  TIter next(dMenuTabs->GetListOfEntries());

  obj = next();
  while(obj){
    TGMenuEntry *entry = (TGMenuEntry*)obj;
    //       printf("%s %d\n",entry->GetLabel()->GetString(),entry->GetEntryId());
    if(mID == entry->GetEntryId()) {
      s = entry->GetLabel()->GetString();
      return s.Data();
    }
    obj = next();
  }

  return 0;
}


Bool_t QwGUIMain::TabActive(const char *str)
{
  int nt = dTab->GetNumberOfTabs();
  for (int i = 0 ; i < nt; i++) {
    TString s = dTab->GetTabTab(i)->GetString();
    if (s == str) {return kTRUE;}
  }
  return kFALSE;
}

Int_t QwGUIMain::GetTabIndex(const char *str)
{
  TString s;
  TString label = str;
  int nt = dTab->GetNumberOfTabs();
  for (int i = 0 ; i < nt; i++) {
    s = dTab->GetTabTab(i)->GetString();
    if (s == label) {return i;}
  }
  return -1;
}


// Wait, but continue to process events.
void QwGUIMain::SleepWithEvents(int seconds)
{
  time_t start, now;
  time(&start);
  do {
    time(&now);
    gSystem->ProcessEvents();
  } while (difftime(now,start) < seconds) ;
}

QwGUISubSystem *QwGUIMain::GetSubSystemPtr(const char *name)
{

  TObject *obj;
  TIter next(SubSystemArray.MakeIterator());
  obj = next();
  while(obj){
    QwGUISubSystem *entry = (QwGUISubSystem*)obj;
    if(!strcmp(name,entry->GetName())){
      return entry;
    }
    obj = next();
  }

  return 0;

}

// void QwGUIMain::PlotMainData(ERPlotTypes ptype)
// {
// }

void QwGUIMain::OnLogMessage(const char *msg)
{
  // Append(msg,kFALSE);
}

// void QwGUIMain::OnObjClose(const char *objname)
// {
//   if(!objname) return;

// //   TString name = objname;

// //   if(name.Contains("dROOTFile")){
// //     dROOTFile = NULL;
// // #ifdef QWGUI_DEBUG
// //     printf("Received dROOTFile IsClosing signal\n");
// // #endif
// //  }

// //   TObject *obj;
// //   TIter next(SubSystemArray.MakeIterator());
// //   obj = next();
// //   while(obj){
// //     QwGUISubSystem *entry = (QwGUISubSystem*)obj;
// //     if(!strcmp(objname,entry->GetName())){
// //       SubSystemArray.Remove(entry);
// //     }
// //     obj = next();
// //   }
// }

void QwGUIMain::OnReceiveMessage(const char *obj)
{
}



Bool_t QwGUIMain::OpenMapFile()
{

  this-> CloseMapFile();

  // // get hostname and user name
  // char host_string[kCharLength];
  // char user_string[kCharLength];

  // gethostname(host_string, kCharLength);
  // getlogin_r (user_string, kCharLength);
  
  // TString host_name = host_string;
  // TString user_name = user_string;
  TString mapfilename = "/dev/shm/";
  
  // if( (host_name.Contains("cdaql4")) and (not user_name.CompareTo("cdaq", TString::kExact)) ) {
  //   mapfilename = "/local/scratch/qweak/";
  // }
  // else {
  //   mapfilename = gSystem->Getenv("QW_ROOTFILES");
  // }

  mapfilename += "/QwMemMapFile.map";


  // hmmm, strange, I cannot catch any error here, 
  // Segmentation fault by using whatever....
  // Friday, October 29 16:19:35 EDT 2010, jhlee


  try 
    {
      //  printf("Reading %s\n", mapfilename.Data());
      //   new TMapFile(mapfilename, "", "READ", kMaxMapFileSize , dMemoryMapFile); // protected..
      //   dMemoryMapFile = TMapFile::Create(mapfilename, "READ",  kMaxMapFileSize, ""); //// default is "read"
      dMemoryMapFile = TMapFile::Create(mapfilename);
    }
  catch  (std::exception& e)
    {
      std::cerr << "exception caught: " << e.what() << std::endl;
    }
  
  if ((dMemoryMapFile->IsOnHeap()) && not (dMemoryMapFile->IsZombie()) ) {
    printf("===== QwRealTimeGUI Reads the RealTime Producer Memory Map File ======\n");
    //    std::cout << dMemoryMapFile << std::endl;
    dMemoryMapFile->Print();
    dMapFileOpen = true;
    printf("======================================================================\n");
  
  }
  else {
    std::cout << "The shared memory region mapped to a file"
	      << mapfilename
	      << " could not be opened." << std::endl;
    dMapFileOpen = false;
  }

  if (dMapFileOpen) {
    TObject *obj;
    TIter next(SubSystemArray.MakeIterator());
    obj = next();
    
    while(obj){
      QwGUISubSystem *entry = (QwGUISubSystem*)obj;
      entry->SetMapFile(dMemoryMapFile);
      obj = next();
    }    
  }
  
  return dMapFileOpen;
};



void QwGUIMain::CloseMapFile()
{
  if (IsMapFileOpen()) {
    TString name = dMemoryMapFile->GetName();
    std::cout << "The memory file " << name
	      << " at the address " 
	      << dMemoryMapFile 
	      << " is closing now."
	      << std::endl;
    dMemoryMapFile->Close();
    dMemoryMapFile = NULL;
  }
  else {
    dMemoryMapFile = NULL;
  }
  dMapFileOpen = false;
  return;
}

void QwGUIMain::CloseWindow()
{
  this->CloseMapFile();
  std::cout << "See you next time without any errors!!!!" << std::endl;
  gApplication->Terminate(0);
  return;
};

Bool_t QwGUIMain::ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2)
{
  //  bool status = 0;
  //std::cout << "  QwGUIMain::ProcessMessage:: msg :" << msg << ", parm1: " << ", parm2: " << parm2 << std::endl;

  switch (GET_MSG(msg))
    {
    case kC_COMMAND:
      {;
	switch (GET_SUBMSG(msg)) 
	  {
	  case kCM_MENU:
	    {;;
	      switch (parm1) 
		{
		case M_VIEW_MAPLOAD:
		  {;;;
		    try 
		      {
			OpenMapFile();
		      }
		    catch (std::exception& e)
		      {
			std::cerr << "exception caught: " << e.what() << std::endl;
		      }
		  };;;
		  break;
		case M_HISTO_RESET:
		  {;;;
		    TObject *obj;
		    TIter next1(SubSystemArray.MakeIterator());
		    obj = next1();
		    while(obj){
		      QwGUISubSystem *entry = (QwGUISubSystem*)obj;
		      entry->SetHistoReset(1);
		      entry->SetHistoAccumulate(0);
		      entry->SetHistoPause(0);
		      obj = next1();
		    }
		  };;;
		  break;
		case M_HISTO_ACCUMULATE:
		  {;;;
		    TObject *obj;
		    TIter next1(SubSystemArray.MakeIterator());
		    obj = next1();
		    while(obj){
		      QwGUISubSystem *entry = (QwGUISubSystem*)obj;
		      entry->SetHistoReset(0);
		      entry->SetHistoAccumulate(1);
		      entry->SetHistoPause(0);
		      obj = next1();
		    }
		  };;;
		  break;
		case M_HISTO_PAUSE:
		  {
		    TObject *obj;
		    TIter next1(SubSystemArray.MakeIterator());
		    obj = next1();
		    while(obj){
		      QwGUISubSystem *entry = (QwGUISubSystem*)obj;
		      entry->SetHistoReset(0);
		      entry->SetHistoAccumulate(1);
		      entry->SetHistoPause(1);
		      obj = next1();
		    }
		  };;;
		  break;
		case M_FILE_EXIT:
		  {;;;
		    this->CloseWindow();
		  };;;
		  break;
		default:
		  break;
		}
	    };;
	  case kCM_BUTTON: 
	    {;;
	      switch(parm1)  
		{
		case  M_LOAD_UNLOAD:
		  {;;;
		    try 
		      {
			if(IsMapFileOpen()) {
			  CloseMapFile();
			  dMainButton[0] -> ChangeBackground(red);
			  dMainButton[1] -> SetEnabled(false);
			  dMainButton[2] -> SetEnabled(false);
			  dMainButton[3] -> SetEnabled(false);
			}
			else {
			  if(OpenMapFile()) {
			    dMainButton[0] -> ChangeBackground(green);
			    dMainButton[1] -> SetEnabled(true);
			    dMainButton[2] -> SetEnabled(true);
			    dMainButton[3] -> SetEnabled(true);
			    SummaryTab->PlotMainData();
			  }
			}
		      }
		    catch (std::exception& e)
		      {
			std::cerr << "exception caught: " << e.what() << std::endl;
		      }
		  };;;
		  break;
		case M_RUN_STOP:
		  {;;;
		    if(dRunStopFlag) { // old true : run -> Stop
		      dMainButton[1] -> ChangeBackground(red);
		      TObject *obj;
		      TIter next1(SubSystemArray.MakeIterator());
		      obj = next1();
		      while(obj){
			QwGUISubSystem *entry = (QwGUISubSystem*)obj;
			entry->SetHistoReset(0);
			entry->SetHistoAccumulate(1);
			entry->SetHistoPause(1);
			obj = next1();
		      }
		      dRunStopFlag = false;
		    }
		    else { /// old false : stop -> want to do Run
		      dMainButton[1] -> ChangeBackground(green);
		      TObject *obj;
		      TIter next1(SubSystemArray.MakeIterator());
		      obj = next1();
		      while(obj){
			QwGUISubSystem *entry = (QwGUISubSystem*)obj;
			entry->SetHistoReset(0);
			entry->SetHistoAccumulate(1);
			entry->SetHistoPause(0);
			obj = next1();
		      }
		      dRunStopFlag = true;
		    }
		  };;;
		  break;
		case M_RESET:
		  {;;;
		    TObject *obj;
		    TIter next1(SubSystemArray.MakeIterator());
		    obj = next1();
		    while(obj){
		      QwGUISubSystem *entry = (QwGUISubSystem*)obj;
		      entry->SetHistoReset(1);
		      entry->SetHistoAccumulate(0);
		      entry->SetHistoPause(0);
		      obj = next1();
		    }
		  };;;
		  break;
		case M_AUTO_RESET:
		  {;;;
		    TString sAutoentries=dtxtEntries->GetText();
		    Int_t iAutoentries=sAutoentries.Atoi();
		    std::cerr << " AUTO RESET Entries:" <<iAutoentries<< std::endl;
		    // dtxtEntries->GetText();
		    TObject *obj;
		    TIter next1(SubSystemArray.MakeIterator());
		    obj = next1();
		    while(obj){
		      QwGUISubSystem *entry = (QwGUISubSystem*)obj;
		      entry->SetAutoHistoReset(iAutoentries);
		      entry->SetHistoReset(1);
		      entry->SetHistoAccumulate(0);
		      entry->SetHistoPause(0);
		      obj = next1();
		    }
		    
		  };;;
		  break;		
		case M_EXIT:
		  {;;;

		    this->CloseWindow();
		  };;;
		  break;
		default:
		  break;
		}
	    };;
	  default:
	    break;
	  }
      };
    default:
      break;
    }
    
  return kTRUE;
};
  
  

Int_t main(Int_t argc, Char_t **argv)
{
  ClineArgs dClArgs = {0};

  dClArgs.realtime = kFALSE;
  dClArgs.checkmode = kFALSE;
  
  if(argv[1]){
    for(Int_t i=1; i < argc; i++){
      if(strcmp(argv[i],"-r")==0){
	dClArgs.realtime = kTRUE;
      }

      if(strcmp(argv[i],"-cm")==0){
	dClArgs.checkmode = kTRUE;
      }

      if(strcmp(argv[i],"-b")==0){
// 	dClArgs.bin = kTRUE;
// 	dClArgs.txt = kFALSE;
      }

      if(strcmp(argv[i],"-t")==0){
// 	dClArgs.bin = kFALSE;
// 	dClArgs.txt = kTRUE;
      }
      if(strcmp(argv[i],"-d")==0){
	dClArgs.detectormap =kTRUE;
	if(argv[i+1]!=NULL){
	  strcpy(dClArgs.file,argv[i+1]);
	  i++;
	}
	else{
	  printf("\n -d provided with no detector map file, exit the program \n Enter the detector map file!  \n\n");
	  exit(1);//if the option -d provided with no detector map file, exit the program
	}

      } 

      if(strcmp(argv[i],"-f")==0){
	if(!argv[i+1] || argv[i+1][0] == '-'){
	  printf("\nMissing value for option -f\n\n");
	  return 0;
	}
// 	strcpy(dClArgs.file,argv[i+1]);
      }

      if(strcmp(argv[i],"-c")==0){
	if(!argv[i+1] || argv[i+1][0] == '-'){
	  printf("\nMissing value for option -c\n\n");
	  return 0;
	}
// 	dClArgs.clmns = atoi(argv[i+1]);
// 	printf("Selected Columns = %d\n",dClArgs.clmns);
      }
    }
  }



  TApplication theApp("QwRealTimeGUI", &argc, argv, 0, 0);
  gROOT->SetStyle("Plain");
  if (gROOT->IsBatch()) {
    fprintf(stderr, "%s: cannot run in batch mode\n", argv[0]);
    return 1;
  }
  QwGUIMain mainWindow(gClient->GetRoot(), dClArgs, 800,600);
  theApp.Run();


  return 0;
}

