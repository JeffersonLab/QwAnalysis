----------------------------------------------------------------------
Multirun_HOWTO
   Bryan Moffit - August 2005

  HOWTO for the multirun analysis

----------------------------------------------------------------------

First, a minimal example, using just a run-slug list:

  1.  Choose the variables that you want included in the multirun
      rootfiles.  See the example in pan/multirun/chooser.txt.
     
  2.  Create a run-slug list with this format:
          <runnumber>  <slugnumber>
     e.g.  Filename = runs.txt
           3018 1
           3019 1
           3020 2

  3.  At the ROOT/CINT prompt, or in a macro, load the following:
          .L multirun/TaVarChooser.C+
          .L multirun/TaPairSelector.C+
          .L multirun/TaMakePairFile.C+
        (or use gROOT->LoadMacro("..."))

  4.  Execute this sequence (similar to multirun/example.C):

          TaMakePairFile *mpf = new TaMakePairFile("myfile.root",
	                                           "multirun/chooser.txt");
          mpf->SetRunList("runs.txt");
          mpf->RunLoop();
          mpf->Finish();

      Where:
	  "myfile.root" 
	      - Filename of the ROOTfile generated by multirun analysis
	  "multirun/chooser.txt" 
              - File to choose variables (from 1.)
          "runs.txt"
              - File that contains the run-slug list (from 2.)


Now... adding additional options (with much more detail, some of which
are used within the multirun/daily.C and multirun/slug.C):


**********************************************************************
   Using the MySQL runlist database.
**********************************************************************

      This database provides a list of runs marked as "Production", as
      well as the slowsign (insertable half-wave plate setting) and
      good detector event ranges (used if there are events in a run
      where a HRS/Septum magnet trouble).  A run-slug list must still
      be provided (unless you'd like to try the database trick in the
      "Using the MySQL runlist as the run-slug list" section).
      Currently, a perl script using DBI is used to grab this runlist
      information because the ROOT version on the adaq machines is not
      compiled with MySQL support.

    * Before starting step 3. from above, run the perlscript 

         utils/getrunlist.pl

      Some example output (from generated runlist.txt file):
        <run>  <slug>  <sign> <LdetLo> <LdetHi> <RdetLo> <RdetHi>
         4041    9       -1      0       0       0       0       
         4042    10      1       0       60000   0       0

    * An extra library must be loaded before the others:

         .L multirun/TaRunlist.C+
        (or use gROOT->LoadMacro("..."))

    * Now, somewhere before running the mpf->RunLoop() command:

          mpf->SetDBRunList("runlist.txt");
        

      A couple notes:
        - Runs in run.txt that are not in the MySQL database 
          WILL NOT be included in the multirun ROOTfile.
        - Slugnumber used will be that obtained from the MySQL database.
        - Detector event ranges will only turn on the detector ok_cut flags:
               ok_cutL - for good Left Detector pairs
               ok_cutR - for good Right Detector pairs
               ok_cutB - for good Left and Right Detector pairs
          if both detectors are not ok, those pairs will not be included
          in the multirun ROOTfile.

**********************************************************************
   Using the MySQL runlist as the run-slug list
**********************************************************************

      The current analysis philosophy is to have ROOTfiles that contain
      all of the runs contained within ONE slug.  Having a ROOTfile
      that contains more than one slug may run into issues with
      Operation System maximum filesize limitations.

      So... here's a way of creating a run-slug list for a given slug
      from the MySQL runlist database (similar to that used by 
      multirun/slug.C)... e.g. for slug = 3, macro filename = slug3.C

      void slug3() {
	// Load all necessary libraries...
	gROOT->LoadMacro("multirun/TaRunlist.C+");
        gROOT->LoadMacro("multirun/TaVarChooser.C+");
        gROOT->LoadMacro("multirun/TaPairSelector.C+");
        gROOT->LoadMacro("multirun/TaMakePairFile.C+");

	Int_t slugnumber = 3;
        TaRunlist dblist("runlist.txt"); // created by getrunlist.pl
	vector <Int_t> templist = dblist.GetListOfRuns(slugnumber);
        vector <pair <UInt_t,UInt_t> > runlist;
	for(UInt_t i=0; i<templist.size(); i++) {
	   runlist.push_back(make_pair(templist[i],(Int_t)slugnumber));
	}
	
	TaMakePairFile *mpf = new TaMakePairFile("slug3.root",
                                                 "multirun/chooser.txt");
        mpf->SetRunList(runlist);
        mpf->SetDBRunlist("runlist.txt"); // Still need detector ranges..
	mpf->RunLoop();
        mpf->Finish();
      }

      Note that this sequence of routines must be in a "compiled"
      macro, because of the use of STL.
      I.e. run with slug3() with:
           .x slug3.C+


**********************************************************************
   Using a "dither" results file for dithering corrections
**********************************************************************

      This feature provides the multirun analysis with dithering
      slopes to do HC position difference corrections to the detector
      asymmetries.
      A TTree "alias" is created, rather than creating new TBranch's.
      The name of this alias, for a given detector, is simply the
      normalized asymmetry name prepended with "dit_".  
	e.g.
         normalized asymmetry for detector 1 = 
             "asym_n_det1"
         corrected normalized asymmetry for detector 1 = 
             "dit_asym_n_det"

    * This "dither" results file is supplied just before the
      mpf->RunLoop() command:

         mpf->SetDitSlopeFile("AvgDitherResFile.txt");

      where "AvgDitherResFile.txt" should be replaced with the name
      of the file that contains the average dithering slopes for
      each detector.

      Two notes for this feature to work properly:
         o results file must be identical to that generated by 
           the "dither" results file created by redana
         o errors on each slope MUST NOT be equal to -1.

