#!/usr/bin/env perl
## Rob Mahurin <rob@jlab.org>, 2010-07-10
use strict;
use warnings;
use File::Basename qw[dirname basename];

my $target = "Analysis/include/ManualFactory.h";
my $scriptname = $0;
my $comment = <<EOF;
## The "correct" way to use the QwSubsystemFactory is with a declaration
##
##	QwSubsystemFactory<Foo> theFooFactory("Foo");
##
## at the top of Foo.cc, which must be linked into libQw; then the
## constructor should be called before the program execution enters
## main().  However, if the execution path to this code isn't
## determined until runtime, the MacOS dynamic library loader may
## optimize the library load away completely.  One way to avoid this
## is to declare theFooFactory as a global variable in the same scope
## as main(), with "extern" linkage.  This should have no effect on
## load times etc. on Linux where those constructors are already called.
##
## This script finds all the "theFooFactory" declarations following
## this pattern, and puts appropriate extern declarations in a header
## file. 
##
## This solution breaks the noble principle of "declare exactly once,"
## but on the other hand it shifts the work of identifying uses of 
## QwSubsystemFactory to the build system.
EOF

$comment =~ s[^##][//]mg;		# poof! it's a c++ comment.

################################################################
## Sanity checking

unless (defined $ENV{QWANALYSIS}) {
  die "$scriptname: QWANALYSIS not defined, not running.\n";
}
unless ($ENV{QWANALYSIS} eq $ENV{PWD}) {
  warn "operating on '$ENV{QWANALYSIS}'\n\t"
    . "but current directory is '$ENV{PWD}'\n\t";
}
$target = "$ENV{QWANALYSIS}/$target";
unless ( -d dirname $target ) {
  die "can't write '$target':\n\t'". dirname($target) ."' not a directory\n";
}

################################################################
## Find Factory declarations

chomp(my @filelist = qx[find $ENV{QWANALYSIS} -name \\*.cc]);
my %need;
FILE: foreach my $file (@filelist) {
  local $/ = ";" ;			# split on c++ lines
  open FH, $file
    or warn "can't open '$file' for reading: $!";
  while (my $line = <FH>) {
    $line =~ s/\s+//g;			# remove whitespaces
    if ($line =~ /QwSubsystemFactory<((Qw)*\w*)> (\w*)\("\1"\);$/x) {
      my $type = $1; 
      my $instance = $3; 
      $need{$type} = $instance;
      unless ($type eq basename($file, ".cc")) {
	warn "name mismatch: factory type '$type' defined in file '$file'\n";
      }
      next FILE;			# weakness: only one instance per file
    }
  }
}

################################################################
## Write the temporary output file

open(my $OUT, ">", "$target.tmp")
  or die "couldn't open $target.tmp: $!";

print $OUT <<EOF;
#ifndef __MANUAL_FACTORY__
#define __MANUAL_FACTORY__

// Header file auto-generated by $scriptname.  Explanation:
//
$comment
EOF

print $OUT qq[#include "$_.h"\n] foreach keys %need;
print $OUT "\n"; 
print $OUT qq[extern QwSubsystemFactory<$_> $need{$_};\n] foreach keys %need;
print $OUT "\n"; 

print $OUT "#endif // __MANUAL_FACTORY__\n"; 

close $OUT;

################################################################
## Replace the target if necessary

if (-e "$target") {
  my $diff = qx[diff $target.tmp $target];
  if ($diff) {
    rename "$target.tmp", $target; 
    print "$target:\n\t REPLACED by $scriptname\n"; 
    exit 0;
  } else {
    unlink "$target.tmp"; 
    print "$target:\n\t UNCHANGED by $scriptname\n"; 
    exit 0;
  }
} else {
  rename "$target.tmp", $target; 
  print "$target:\n\t WRITTEN by $scriptname\n"; 
  exit 0;
}
